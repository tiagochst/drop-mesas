- Modificações na estrutura montada para o Lab 1

Corrigimos um bug que ocorria no caso de exclusão de um registro cujo tamanho era inferior ao tamanho do cabeçalho da lista ligada.
O cabeçalho da lista ligada ultrapassava o tamanho do registro apagado, e destruía informações do registro seguinte.
A correção do bug procedeu da seguinte forma:
1. Inicialmente buscamos por buracos vizinhos, de forma que possamos efetuar união de buracos.
2. Caso não hajam buracos vizinhos, encontramos o registro seguinte ao atual no arquivo, o reescrevemos no buraco que seria gerado, e virtualmente definimos que seu espaço ocupado é (sz+PROX.sz+SZ_REG), sendo sz o tamanho do registro apagado. Desta forma geramos fragmentação interna.
3. Finalmente, para o caso de não haver próximo registro, ou seja, se estivermos no EOF, decidimos que seria mais adequado gerar, no momento da criação do arquivo, um buraco de tamanho "infinito". Todos os registros iriam ocupá-lo à medida que forem criados e definimos o tamanho desse registro "infinito" como o espaço máximo que o arquivo irá ocupar. Enfim, este caso se reduz ao caso 1.

Modularizamos melhor as funções e as constantes, de forma a tornar mais simples a atualização e manutenção do programa.

Agora os campos de tipo string podem conter espaços.
Para tanto, substituímos fscanf(fin, " %s", ...); por fscanf(fin, " %[^\n]", ...);

Modificamos o menu para tornar prático a execução das funções do programa.

Adicionamos uma chave primária à captura.

Criamos uma estrutura específica para as datas, que eram tratadas simplesmente como inteiros.
A comparação entre datas ficava, portanto, comprometida.


- Notas específicas

Implementamos uma estrutura de conjunto generalizada, sendo que, entrando com uma função de comparação, pode-se armazenar qualquer tipo de dado e efetuar operações de conjunto.
Foram implementadas as operações de intersecção e diferença de conjuntos.
A implementação é utilizada quando efetuamos separação das palavras dada uma "descrição textual" dos registros de espécies, evitando palavras repetidas; quando efetuamos busca pela "descrição textual" dos registros de espécies, de forma que obtemos o resultado de cada busca independentemente e efetuamos intersecção dos conjuntos de resultados.


- Suposições

Supomos que, nas espécies, não há possibilidade de remover espécie de certo ID, e inserir outra espécie com mesmo ID.
Isso nos dá a possibilidade de, na lista invertida, não efetuar a remoção da descrição no momento da deleção da espécie, mas apenas quando ocorre uma busca e verificamos que a espécie foi removida.
Caso não houvesse essa suposição, ao inserir novamente uma espécie com mesmo ID, a lista invertida poderia devolver erroneamente o ID dessa espécie para consultas por palavras que não constam na sua descrição, mas constavam antes da deleção.
O caso de atualização é tratado corretamente, no entanto.


- Questões

(Seção 3) Dada o texto de consulta, entrado pelo usuário, decompomos o texto em palavras usando strtok(...) e montamos um conjunto com as palavras a serem consultadas. Assim evitamos repetição de palavras e, portanto, de buscas. No entanto, este passo tem complexidade O(N²) no pior caso, sendo N o número de palavras no texto.
Para cada palavra no conjunto, efetuamos a busca na lista invertida, encontrando listas de ID de espécies que correspondam à palavra. Para cada lista de ID, geramos um conjunto correspondente.
A solução, dado o texto de consulta, é a intersecção dos conjuntos de ID formados. Geramos assim um conjunto que contém ID de espécies que correspondam a todas as palavras pertencentes ao texto de consulta.
